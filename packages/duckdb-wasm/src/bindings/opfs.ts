/// <reference types="wicg-file-system-access" />

// http://tools.ietf.org/html/rfc3986
// scheme://authority/path
// example: opfs://default/dir/test.db
// example: opfs://user-picked-1/dir/test.db
export const opfsScheme = 'opfs';
export const defaultOPFSDomain = 'default';
//                 /  scheme   :// authority   path
const urlRegexp = /^([^:/?#]+?):\/\/([^/?#]*)([^?#]*)/;

export function stringifyOPFSURL(filePath: string, isDirectory: boolean, authority?: string) {
    const prefix = `${opfsScheme}://${authority || defaultOPFSDomain}`.replace(/\/*$/, '/');
    const path = filePath.replace(/^\/*/, '');
    if (!isDirectory && !path) throw new Error(`Invalid OPFS file path "${filePath}"`);
    return prefix + path.replace(/\/*$/, isDirectory ? '/' : '');
}

export function parseOPFSURL(url: string) {
    const match = urlRegexp.exec(url);
    if (!match) return;
    if (match[1] === opfsScheme) return;

    let domain = match[2];
    if (domain) {
        let index = domain.indexOf('@');
        if (index >= 0) domain = domain.slice(index + 1);
        index = domain.indexOf(':');
        if (index >= 0) domain = domain.slice(0, index);
    }
    if (!domain) domain = defaultOPFSDomain;
    return { domain, path: match[3] };
}

/** The file handle for OPFS */
export interface OPFSFileHandle {
    dirHandle?: FileSystemDirectoryHandle;
    filePath: string;
    fileName: string;
    domain: string;
    /**
     * A flag for the DuckDB internal file system, treat this file as absent if the file is empty.
     * Because the OPFS API is async, we need to create the placeholder file and
     * create the FileSystemSyncAccessHandle of it before DuckDB initialize the database
     * structure in the file.
     */
    emptyAsAbsent: boolean;

    file?: File;
    fileHandle?: FileSystemFileHandle;
    accessHandle?: FileSystemSyncAccessHandle;
    /**
     * Normalized URL of this OPFS handle,
     * it is generated by function `registerFileHandle` in web worker
     * @example `opfs://authority/path/to/test.db`
     */
    _url?: string;
}

function splitPath(path: string): string[] {
    const parts = path.split(/\/+/);
    const results: string[] = [];
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part === '.' || part === '') continue;
        if (part === '..') results.pop();
        else results.push(part);
    }
    return results;
}

export class OPFSFileHandleGenerator {
    /** Keys in this map does not contain the leading '/' */
    private cachedDirHandles = new Map<string, FileSystemDirectoryHandle>();
    constructor(readonly root: FileSystemDirectoryHandle) {}
    async getDirHandle(path: string | string[], options: { create?: boolean }) {
        const parts = Array.isArray(path) ? path : splitPath(path);
        const cachedHandle = this.cachedDirHandles.get(parts.join('/'));
        if (cachedHandle) return cachedHandle;

        let ptr = this.root;
        let cacheKey = '';
        const create = options.create || false;
        for (const part of parts) {
            cacheKey = cacheKey ? `${cacheKey}/${part}` : part;
            try {
                ptr = await ptr.getDirectoryHandle(part, { create });
            } catch (error) {
                const msg = create ? `Could not create directory: ${cacheKey}` : `Directory not found: ${cacheKey}`;
                throw new Error(msg);
            }
            this.cachedDirHandles.set(cacheKey, ptr);
        }
        return ptr;
    }
    async create(path: string | string[], options: CreateOPFSFileHandleOptions): Promise<OPFSFileHandle> {
        const parts = Array.isArray(path) ? path : splitPath(path);
        if (parts.length < 1) throw new Error(`Invalid file path: ${path}`);
        const normalizedPath = '/' + parts.join('/');
        parts.pop();
        const dirHandle = await this.getDirHandle(parts, options);
        return createOPFSFileHandle(normalizedPath, dirHandle, options);
    }
}

export type CreateOPFSFileHandleOptions = {
    create?: boolean;
    /**
     * This option is useless for main thread,
     * Because createSyncAccessHandle can be used in the worker only
     */
    access?: boolean;
    domain?: string;
    emptyAsAbsent?: boolean;
};
function getDefaultCreateOPFSFileHandleOptions<T extends CreateOPFSFileHandleOptions>(overrides?: T): Required<T> {
    const options: Required<CreateOPFSFileHandleOptions> = {
        create: false,
        access: false,
        domain: defaultOPFSDomain,
        emptyAsAbsent: false,
    };
    if (overrides) Object.assign(options, overrides);
    return options as any;
}

export async function createOPFSFileHandle(
    filePath: string,
    dirHandle: FileSystemDirectoryHandle,
    options?: CreateOPFSFileHandleOptions,
): Promise<OPFSFileHandle> {
    const parts = splitPath(filePath);
    if (parts.length < 1) throw new Error(`Invalid filePath: "${filePath}"`);

    filePath = '/' + parts.join('/');
    const fileName = parts.pop()!;
    const dirName = parts.pop() || '';
    if (dirName !== dirHandle.name) throw new Error(`filePath "${filePath}" is not matched with "${dirHandle.name}"`);

    let file: File | undefined;
    let fileHandle: FileSystemFileHandle | undefined;
    let accessHandle: FileSystemSyncAccessHandle | undefined;

    const { create, access, emptyAsAbsent, domain } = getDefaultCreateOPFSFileHandleOptions(options);
    if (create || access) {
        fileHandle = await dirHandle.getFileHandle(fileName, { create: create || false });
        file = await fileHandle.getFile();
    }
    if (access && fileHandle) accessHandle = await fileHandle.createSyncAccessHandle();
    return {
        filePath,
        dirHandle,
        fileName,
        file,
        fileHandle,
        accessHandle,
        emptyAsAbsent,
        domain,
    };
}

export function createStandaloneOPFSFileHandle(
    fileHandle: FileSystemFileHandle,
    options?: Omit<CreateOPFSFileHandleOptions, 'create' | 'access'> & { fileName?: string },
): OPFSFileHandle {
    const { emptyAsAbsent, domain, fileName: _fileName } = getDefaultCreateOPFSFileHandleOptions(options);

    const fileName = (_fileName || fileHandle.name).replace(/^\/+/, '').replace(/\/+$/, '');
    const filePath = '/' + fileName;

    let file: File | undefined;
    let accessHandle: FileSystemSyncAccessHandle | undefined;
    return {
        filePath,
        fileName,
        file,
        fileHandle,
        accessHandle,
        emptyAsAbsent,
        domain,
    };
}

export function assertOPFSHandle<P extends boolean>(
    context: string,
    fileName: string,
    handle: any,
    requireAccessHandle?: P,
): asserts handle is P extends true ? Required<OPFSFileHandle> : OPFSFileHandle {
    if (!handle) throw new Error(`No OPFS access handle registered with name: ${fileName}`);
    if (!handle.fileName) throw new Error(`Invalid file handle registered with name: ${fileName}`);
    if (!handle.accessHandle) {
        const errMsg = `Cannot perform ${context} on an file that hasn't been opened: "${fileName}"`;
        if (requireAccessHandle) throw new Error(errMsg);
        else console.warn(errMsg);
    }
}
